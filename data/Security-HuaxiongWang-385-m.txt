
fit

F
N
Z
v
w
S
R
u
s
m
0
1
a
b
c
x
y
W
M
G
P
lcm

op-tical net-works semi-conduc-tor



Binary de Bruijn Sequences via Zech's Logarithms
Zuling Chang Martianus Frederic Ezerman Adamas Aqsa Fahreza San Ling 

Janusz Szmidt Huaxiong Wang
Z. Chang et al.

Z. Chang School of Mathematics and Statistics, Zhengzhou University, Zhengzhou 450001, China

zulingchang@zzu.edu.cn
M. F. Ezerman A. A. Fahreza S. Ling H. Wang Division of Mathematical Sciences, School of Physical and Mathematical Sciences,

Nanyang Technological University, 21 Nanyang Link, Singapore 637371

fredezerman,adamas,lingsan,HXWang@ntu.edu.sg
J. Szmidt Military Communication Institute, ul. Warszawska 22 A, 05-130 Zegrze, Poland

j.szmidt@wil.waw.pl


Received: date / Accepted: date
	


The cycle joining method and the cross-join pairing are two main construction techniques for de Bruijn sequences. This work shows how to combine Zech's logarithms and each of the two techniques to efficiently construct binary de Bruijn sequences of large orders. A basic implementation is supplied as a proof-of-concept.

In the cycle joining method, the cycles are generated by an LFSR with a chosen period. We prove that determining Zech's logarithms is equivalent to identifying conjugate pairs shared by any pair of cycles. The approach quickly finds enough number of conjugate pairs between any two cycles to ensure the existence of trees containing all vertices in the adjacency graph of the LFSR. When the characteristic polynomial of the LFSR is a product of distinct irreducible polynomials, the approach via Zech's logarithms combines nicely with a recently proposed method to determine the conjugate pairs. This allows us to efficiently generate de Bruijn sequences with larger orders. Along the way, we establish new properties of Zech's logarithms. 

The characterization of conjugate pairs via Zech's logarithms as positional markings is then adapted into identifying cross-join pairs in a de Bruijn sequence. We start from any de Bruijn sequence, although typically a modified -sequence for ease of generation, and demonstrate how to use Zech's logarithms to identify all cross-join pairs in that sequence. The process can be repeated on each of the resulting sequences until a desired number of distinct sequences are produced. The computational process can be made more efficient by using a new analytic tool attributed to Fryers as well as prior algorithmic tools. 

Binary de Bruijn sequence cycle structure conjugate pair cross-join pair Zech's logarithms

11B50 94A55 94A60

Introduction
A binary de Bruijn sequence of order  has period  in which each -tuple occurs exactly once. Up to cyclic equivalence, there are  of them . Mainly for cryptographic purposes, there has been a sustained interest in efficiently generating a good number of de Bruijn sequences of large order. 

Adding a  to the longest string of s in a maximal length sequence (also known as an -sequence) of period  produces a de Bruijn sequence of order . There are  such -sequences where  is the Euler totient function. There is a bijection between the set of all such sequences and the set of primitive polynomials of degree  in . As  grows large,  soon becomes miniscule in comparison to . It is then natural to widen the choice of constructions.

Two general construction approaches are the cycle joining and the cross-join pairing methods. Using the former we can start, say, with a linear feedback shift register (LFSR) with an irreducible but nonprimitive characteristic polynomial of degree . It produces disjoint cycles, each has a period that divides . We identify a conjugate pair between any two distinct cycles and combine the cycles into a longer cycle. We repeat this cycle joining process until all disjoint cycles have been combined into a de Bruijn sequence. The process can of course be done on all identifiable conjugate pairs. The latter method begins with a known de Bruijn sequence, usually a modified -sequence. We then identify a cross-join pair that allows the cycle to be cut and reconnected into a different de Bruijn sequence from the one we started with. The conjugate pairs and the cross-join pairs are defined to ensure that the respective resulting sequences are in fact de Bruijn.
	
This paper focuses on handling large order  using either of the two methods above. We aim to vastly improve on prior results, both in the number of de Bruijn sequences produced and the efficiency of the constructions. At the core of our method is the use of Zech's logarithms to characterize the conjugate pairs as positional markings. We show how to adapt finding conjugate pairs shared by two smaller cycles in the cycle joining method to finding two conjugate pairs in a given de Bruijn sequence to use as a cross-join pair, showing how closely connected the two methods are. 

In terms of organization, after this introduction we review relevant notions and results on FSRs and Zech's logarithms in Section . New properties of Zech's logarithms can also be found towards the end of that section. Section  characterizes conjugate pairs by Zech's logaritms, benefitting from a carefully chosen representation of the states. Section  discusses the adjacency graph and several methods to identify its spanning trees. A basic software impementation for the cycle joining method is given in Section . Section  explains how to integrate a recent proposal of using the product of irreducible polynomials as the characteristic polynomial of the starting LFSR into the current framework. Adapting the Zech's logarithms approach to identify cross-join pairs in an -sequence is the core of Section . We end with some conclusions and a general open problem in Section .

PreliminariesLet  be the set of positive integers and, for integers , let  denote . A cyclotomic coset of  modulo  containing  is  with  the least positive integer such that . 
Obviously . For each , the least integer in  is its coset leader. The set of all coset leaders is called a complete set of coset representatives, denoted by .

Feedback Shift Registers


An -stage shift register is a clock-regulated circuit with  consecutive storage units, each containing a bit. As the clock pulses, each bit is shifted to the next stage in line. A binary code is generated if one adds a feedback loop that outputs a new bit  based on the  bits  called an initial state. The codewords are the -bit states. The Boolean function  that outputs  on input  is called its feedback function. The algebraic normal form (ANF) of  is  with  and the sum is over all -subsets . The degree of  is the largest  for which .

A feedback shift register (FSR) outputs  satisfying the recursion  for . If  for all , then  is -periodic
or with period , denoted by . The -th state of  is  and  is the successor of . We use  or  to denote the all zero vector or sequence of period . The latter is preferred when the length  needs to be specified.

Distinct initial states generate distinct sequences, forming the set  of  elements. A state operator  turns  into , , . 
If  has a state  and period , the  distinct states of  are
. The shift operator  sends  to 
 
with the convention that . The set  
is a shift equivalent class or a cycle in . 
One can partition  into cycles and writes the cycle structure as


An FSR with a linear feedback function is linear (or an LFSR) and nonlinear (or an NLFSR) otherwise. The characteristic polynomial of an -stage LFSR is 

when the feedback function is . To ensure that all generated sequences are periodic, . 
A sequence  may have many characteristic polynomials. The one with the 
lowest degree is its minimal polynomial. It represents the LFSR of 
shortest length that generates . Given an LFSR with characteristic 
polynomial , the set  is also denoted by . 
To  in (), one associates a matrix

On input state , the state vectors of the resulting sequence are  for  and .

If the minimal polynomial of a sequence is primitive with degree  and  as a root, then it can be obtained by applying the trace map from  onto  on the sequence . The sequence is said to be a maximal length sequnce or an -sequence since it has the maximal period among all sequences generated by any LFSR with minimal polynomial of degree . Let  denote an -sequence. A sequence  is a -decimation sequence of , denoted by  if  for all . A -decimation  of  is also an -sequence if and only if . More properties of sequences in relation to their characteristic and minimal polynomials can be found in  and.

Zech's Logarithms

Among computational tools over finite fields we have Zech's logarithm (see , ). The logarithm is often referred to as Jacobi's logarithm . It was Jacobi who introduced the notion and tabulated the values for  with  in .
For , the Zech's logarithm  relative to  is defined by  where . It induces a permutation on . Huber established the following properties of Zech's logarithms over  and provided the Zech's logarithm tables for  with  in . 


It suffices to find the logarithms relative to one primitive element. 
Let distinct primitive polynomials  and  be of degree  with respective roots  and . 
Then  for some  with . Let  and  
denote the respective logarithms of  relative to  and . Then 




Hence, . With a primitive element fixed, the notation is  or  to emphasize .
	
The  map is given by . Knowing  for any  in a cyclotomic coset  is sufficient to find  by using the  map

The  and  maps send cosets onto cosets of the same size. 
	
Let . Then

 maps a coset onto a coset of the same size. 
	
Let  be a primitive polynomial of degree  having a root 
. Let  and  with . If the Zech's logarithms relative to  are known, then .
Hence,


Repeatedly applying  and  induces a cycle of  cosets, except in rare cases (see ). Using the  map, one then gets the value of  for all  in the union of these cosets. To complete the table, Huber suggested the use of key elements, each corresponding to a starting coset. Instead of following the suggestion, we introduce a more efficient route that reduces the storage need.

For known , , and ,



For ,  if and only if . This is equivalent to . 
Thus, . To apply Lemma , one looks for an  pair such that the respective Zech's logarithms of , and  are already known, , the elements , and  are in the union  of cosets with known Zech's logarithms, but . In many cases, a given Zech's logarithm is sufficient to deduce all others values. We can write Equation () as 
.

We reproduce the table in  for  
without any key element. The computations are done modulo  with  replacing  for brevity. There are  cyclotomic cosets of  modulo : the trivial coset , a coset of cardinality ,  cosets, each of cardinality , and  cosets, each of cardinality . The coset  implies . The cycle of  cosets beginning from  is 
, giving the logarithms of all  elements in . 
For the remaining logarithms, one searches for an  pair with  not in any of previously known cosets but  is. A simple python routine completes the task for the remaining cosets as summarized in Table . The rows follow chronological order. 	
[h!]
Zech's Logarithms for Elements in Remaining Cosets of Example .



The approach in Example  may fail to yield the complete table. 
We tested all trinomials  with  and  since the reciprocals give identical conclusions. When , the full table is obtained for . When , Lemma  produces the full table for  but fails for . It also fails for  but works for  and . In case of failure, the computation in () becomes necessary. 
Zech's Logarithms and Conjugate Pairs
A state  and its conjugate  form a conjugate pair. Cycles  and  in  are adjacent if they are disjoint and there exists  in  whose conjugate  is in . Adjacent cycles merge into a single cycle by interchanging the successors of  and . The feedback function of the resulting cycle is

Continuing this step, all cycles in  join into one cycle, which is a de Bruijn sequence. This is the cycle joining method. The feedback functions of the resulting de Bruijn sequences are completely determined once the corresponding conjugate pairs are found. 

Basic Notions and Known Results

 The adjacency graph  of an FSR with feedback function  is an undirected multigraph whose vertices correspond to the cycles in . There exists an edge between two vertices if and only if they are adjacent. A conjugate pair labels every edge. The number of edges between any pair of cycles is the number of conjugate pairs that they share.
Clearly  has no loops. There is a bijection between the spanning trees of  and the de Bruijn sequences constructed by the cycle joining method (see. ,   and ). The following well-known counting formula is a variant of the BEST (de Bruijn, Ehrenfest, Smith, and Tutte) Theorem from . Recall that the cofactor of entry  in  is  times the determinant of the matrix obtained by deleting the -th row and -th column of .

(BEST) Let  be the vertex set of the adjacency graph  of an FSR. Let  be the  matrix derived from  in which  is the number of edges incident to vertex  and  is the negative of the number of edges between vertices  and  for . Then the number of the spanning trees of  is the cofactor of any entry of .

In using the cycle joining method to generate large order de Bruijn sequences, efficient identification of conjugate pairs is crucial. A de Bruijn sequence generator has been recently proposed in . Its basic software implementation   demonstrates a decent performance up to order  when the characteristic polynomials are products of distinct irreducible polynomials. As the period grows large the program runs into time complexity issues. Another recent contribution can be found in . The work shows how to generate de Bruijn sequences of large orders, say , but without supplying time or space complexity analysis. The above examples indicates that dealing with large order demands much faster algorithmic tools.

Let  be the Mobius function. There are  binary irreducible polynomials of degree . All irreducible polynomials of (prime) degree  are primitive if and only if  is prime. Such an  is called a Mersenne exponent. Although not known to be finite, Mersenne exponents are sparse . Thus, for most , there are many more irreducible than primitive polynomials. Each such polynomial yields a number of de Bruijn sequences if one can efficiently identify the conjugate pairs. We show how to accomplish this task.

A primitive polynomial  of degree  having a (primitive) root  can be identified in several ways, (see, ,  ). Many computer algebra systems have routines that output primitive polynomial(s) of a specified degree. Combining a decimation technique and the Berlekamp-Massey algorithm on input  and a suitable divisor  of  yields the associated irreducible polynomial . It has degree , order , and a root  with . Notice that  is the least integer satisfying . 

The  distinct nonzero cycles in  can be ordered in the language of cyclotomic classes and numbers using a method from . The cyclotomic classes , for , are

The cyclotomic numbers , for , are

Using the basis  for  we write 
with  for . In vector form, the expression becomes

Define the mapping  by

where the subscripts are reduced modulo .
By the recursive relation determined by (),  is a bijection. Let

It is now straightforward to verify that 

with  as the initial state of  for . 
In particular, the initial state of  is . Note that  induces a correspondence between  and  (see ). 
In other words,  and the sequence of states of ,
namely , where




for ,
are equivalent. The state  corresponds to the
element . Hence, . 
This provides a convenient method to find the exact position of any state 
 in some cycle in . 

	
The states  and  form a conjugate pair for all .

Efficient Exact Determination of Conjugate Pairs

We extend Proposition  by explicitly determining the respective exact positions of the states in their corresponding cycles. 
This is far from trivial. First, one needs to fix a standard representation of the cycles and then uses algebraic tools to find the very location of  in  and  in . 


Let 
 for some . Then  must be the -th state of . Let  and suppose that 
. We have  from the definition of . 
Note that if  in () is irreducible, then . Since ,
*
& ^k+t =_n-1a_^+1= 
_n-2a_ ^+1+_n-1a_n-1 c_ ^ = 

& a_n-1+(a_0+a_n-1c_1)++(a_n-2+a_n-1c_n-1)^n-1.
Continuing inductively, it becomes clear that  is the constant term in the linear combination of  in the  basis. Hence,










Once  and the Zech's logarithms relative to  are known, one gets  and, thus, 
's position.

How can one efficiently generate the cycles in ? Directly using the above definition is not practical since it requires 
costly computations over . Simply generating them by the LFSR with characteristic polynomial  may fail to 
guarantee that their respective initial states are  for . We show that decimation is the right tool.

Equation () ensures that  is an -sequence 
with characteristic polynomial  .
The trace function  maps  to . Recall, , from  that the entries in  are  for .
From , construct  distinct -decimation sequences of period :



The resulting sequences have  for  and . 
Each  is a cycle in  since . 
We need to find an initial state  of  such that the initial state of  is .

Let  be the associate matrix of . Then the respective first elements of  for  must be . A system of equations to derive  can be constructed. Let  be the number of s in the binary representation 
of . Computing  is efficient using the square-and-multiply method, taking at most 
 squarings and  multiplications.

We use  and  to derive the first  entries of . The respective initial states  of  in  immediately follow by decimation. Thus, one gets  for any .
This allows us to quickly find the desired initial state of any cycle, even for large .
Given the state , we have  . At this point, given an irreducible polynomial  with root  and order , 
we need a primitive polynomial  with the same degree as  and a root  satisfying . In general, such a  is not unique . Here we provide a method to find one.

For ,
let  be a primitive polynomial of degree
 that generates the -sequence . The set of all
shift inequivalent -sequences with period  is
. The elements are the -decimation sequences of any  for all  satisfying . We derive  of period  and check if it shares a common string of  consecutive elements with a sequence whose characteristic polynomial is . If yes, then we associate  with . Testing all s guarantees a match between  and some  without 
costly operations over .

As  or  grows, finding one such  becomes more computationally involved. To work around this limitation, one starts instead with any primitive polynomial  with a root  and find the corresponding irreducible  having  as a root. There are tools from finite fields (see, , )
that can be deployed. We prefer another approach that does not require computations over .

Any primitive polynomial  generates an -sequence . By -decimation we get . We input any  consecutive bits of  into the Berlekamp-Massey algorithm  to get an irreducible
polynomial  having  as a root. There are instances where
 has degree  with . This implies that, for this , there is no irreducible polynomial of degree  that can be associated with . As  traverses , by -decimation and the Berlekamp-Massey algorithm, the process provides all irreducible polynomials with root . The resulting polynomials form the set of all irreducible polynomials with degree . 

For ,  is valid to use if and only if .


Constructing irreducible polynomials is important in the study of finite fields.
The Ben-Or and Rabin tests for irreducibility are widely used. The source codes are given in . 

Our procedure finds irreducible polynomials of degree  satisfying  given any primitive polynomial of degree  using only decimation and the Berlekamp-Massey algorithm with running time . 

Given a valid , let  be the respective associated primitive polynomial of the irreducible polynomial , both of degree . Let the -sequence  whose characteristic polynomial is  be the -decimation sequence of the -sequence  generated by . Then we have the commutative diagram 






	


Let  be a primitive root of . Hence, there exists a root  of  such that . Applying the trace map  shows that the two directions coincide by the commutativity of the exponents in a multiplication. 
We can now characterize the conjugate pairs shared by any two distinct cycles by Zech's logarithms. In fact, determining the respective initial states of  is not even necessary since ensuring that  is the initial state of  is sufficient for implementation. 

Let  be a root of a primitive polynomial  of degree  and  be the Zech's logarithm with respect to . Let  be the irreducible polynomial of degree  and order  having a root , ,  is associated with . 

Let  and  be distinct nonzero cycles in  constructed above, ,  with . Let  be the -th state of  and  be the -th state of . Then  forms a conjugate pair if and only if .


Let  and  be elements of . 
Then  is a state of  if and only if 
 and . It is therefore clear that . 
Observe that  and  are conjugate. 
The conjugate of  with  is





The conjugate of any state  in cycle  must then be  in cycle .
In other words, the conjugate of the -th state of cycle , which is 
, must be . 
Writing  with 
 and , 
 
belongs to . 

Thus, knowing the Zech's logarithms relative to  enables us to 
easily determine all conjugate pairs between two arbitrary cycles in . 
By the definition of cyclotomic numbers,  and  share  conjugate pairs. 

Conversely, knowing all of the conjugate pairs allows us to derive the Zech's logarithms relative to .
Let a conjugate pair  with 
and  be given. Then  since 
 must be . If all of the conjugate pairs are known, a complete Zech's 
logarithm table, relative to , follows. 


Given , which is irreducible, of order  with  as a root, 
choose  with a root  satisfying  as the associated 
primitive polynomial. Let  be the corresponding -sequence with initial state . By -decimating one derives  with , , and . The nonzero -stage states are


.
The respective Zech's logarithms are 



All conjugate pairs between any two nonzero cycles can be determined 
by Theorem . Knowing , for example, one concludes 
that  and  share the pair  and . Conversely, knowing a conjugate pair is sufficient to determine the corresponding Zech's logarithm. 
Since  and  form a conjugate pair between  and , for instance, one gets .

The feedback function derived from  is . By Equation (), the merged cycle joining  and  based on the conjugate pair  and  has the feedback function
. Appending  to the resulting cycle using the conjugate pair  and  shared by  and , results in the feedback function  that produces a sequence of period . Appending a  to the string of  zeroes in the sequence gives us the de Bruijn sequence . 
If  in Theorem  is primitive, then the output is an -sequence . Let . 
The -th state  and the -th state  form a conjugate pair. To compute  for  it suffices to determine the position of the state  by searching. This fact can be used to find the Zech's logarithms when  is not very large. 
Spanning Trees
Constructing Enough Number of Spanning Trees

When  is large or  is a large valid divisor of , building  completely is possible but very often unnecessary and consumes too much resources. It is desirable to find just enough Zech's logarithms to identify a required number of spanning trees. Since there is a unique pair that joins  and  into one cycle, our focus is on the set of nonzero cycles . 

Let . If  with , 
then  and  are adjacent. They are joined into one cycle 
by the conjugate pair

with  the initial state of  and  that of . 
We continue the process by identifying some conjugate pair(s) between enough pairs of adjacent cycles until all of the cycles in  can be joined. 

Let  for some  be known. This induces a mapping from  onto 
 with . If , then, 
for , states  and  belong to 
distinct cycles. These states join their corresponding cycles into one. Let  be the least positive integer such that . 
Observe that  and 
are states of the same cycle and . Hence, given cosets  
and , one derives  
distinct conjugate pairs between each of the  distinct pairs of cycles.

The Zech's logarithms supply the exact positions of the conjugate pair(s) in the relevant 
cycles. Once enough conjugate pairs to construct a spanning tree are identified, 
the precise positions to apply the cycle joining method, , to exchange successors, appear. 
Thus, with  as the initial state of , we just need to keep 
track of the precise positions, in terms of the operator  and the power of , 
governed by the  pair. The actual construction of the de Bruijn sequences 
no longer requires storing the initial states of the  nonzero sequences 
in . 

Consider  and let  be a root of , implying . 
Choosing , the Berlekamp-Massey algorithm outputs 



Hence, . 
Let  be the initial state of . 

Knowing a specific  pair gives us . 
Note that  for all .

Since , there are  distinct pairs of cycles, each sharing  conjugate pairs. 
The  pairs  are the indices of the cycles. 
One of the  conjugate pairs between  and  is 
 since  and . 
Computing  and  are easy given the relevant logarithms, so we omit them from the rest of this example. 

Since ,  shares  conjugate pairs each with  for . Similarly, each adjacent cycles in the list



shares  conjugate pairs. We order the cycles as  and build an adjacency subgraph  from the  
computational results. Applying Theorem  with 
 replaced by , the approach produces  de Bruijn sequences. Figure  is a spanning tree. 



[auto, node distance=1.1cm, every loop/.style=,
                    thick,main node/.style=draw,font=]

  [main node] (1) ;
  [main node] (2) [left of=1] ;
  [main node] (3) [above of=1] ;
  [main node] (4) [left of=3] ;
  [main node] (5) [left of=4] ;
  [main node] (6) [right of=3] ;

  [main node] (7) [right of=6];
  [main node] (8) [above of=3] ;
  [main node] (9) [left of=8] ;
  [main node] (10) [left of=9] ;
  [main node] (11) [right of=8] ;
  [main node] (12) [right of=11] ;
  
  [main node] (13) [above of=8] ;
  [main node] (14) [left of=13] ;
  [main node] (15) [left of=14] ;
  [main node] (16) [right of=13] ;
  [main node] (17) [right of=16] ;
  
  [main node] (18) [above of=13] ;
  [main node] (19) [left of=18] ;
  [main node] (20) [left of=19] ;
  [main node] (21) [right of=18] ;
  [main node] (22) [right of=21] ;

  [main node] (23) [below of=1] ;
  [main node] (24) [left of=23] ;
  [main node] (25) [left of=24] ;
  [main node] (26) [right of=23] ;
  [main node] (27) [right of=26] ;
  
  [main node] (28) [below of=23] ;
  [main node] (29) [left of=28] ;
  [main node] (30) [left of=29] ;
  [main node] (31) [right of=28] ;
  [main node] (32) [right of=31] ;
    
  [every node/.style=font=]
    (1) edge (2) 
        edge (3)
        edge (4) 
        edge (5)
        edge (6) 
        edge (7)
        edge (23) 
        edge (24)
        edge (25) 
        edge (26)
        edge (27) 
    (5) edge (10)
    (10) edge (15) 
	(15) edge (20) 
	
	(4) edge (9)
    (9) edge (14) 
	(14) edge (19)
	
	(3) edge (8)
    (8) edge (13) 
	(13) edge (18)
	
	(6) edge (11)
    (11) edge (16) 
	(16) edge (21)
	
	(7) edge (12)
    (12) edge (17) 
	(17) edge (22)
	
	(25) edge (30)
    (24) edge (29)
	(23) edge (28)
	
	(26) edge (31)
    (27) edge (32);

A spanning tree in an adjacency subgraph  of .

A Note on Dong and Pei's Construction

Dong and Pei recently proposed a construction of de Bruijn sequences with large order in . Given an irreducible polynomial  of degree , order , and , they defined a shift register matrix  in the form of () satisfying  where  is the reciprocal polynomial of . 
Given the sequence  with initial state , one can write 
any sequence as , where  is some polynomial of degree . 
If , then  and  are distinct cycles sharing the conjugate pair . Here  is a state of . Their claim that  shares some conjugate pairs with each of the other nonzero cycles does not hold in general. 

First, as  and  grow large, computing  soon becomes prohibitive. 
Second, after  is verified, it remains unclear which cycle  corresponds to. One is still unable to judge whether it is possible to join all of the cycles in  
even after a lot of the conjugate pairs have been determined. 
Third, and most importantly,  is a necessary condition for 
their method to work . In fact, a sufficient and necessary condition is  for all . This does not hold in general. Take, for example,  with  and . All values  
such that  form the set  
*
X:=&85,105,141,170,210,277,282,291,325,337,340,341,379,420,431,493,

     &554,564,582,650,657,674,680,682,701,727,758,840,862,875,949,986.
Hence,  can be joined only to  with 



Since only  out of the required  cycles can be joined with , 
Dong and Pei's approach fails to produce de Bruijn sequences here. We show in the next subsection that our method handles such a situation perfectly.

Star and Almost-Star Spanning Trees

In cases where  is adjacent to  for  Theorem  rapidly certifies the existence of a star spanning tree centered at . This helps in quickly generating at least a de Bruijn sequence of order . The certificate contains the following outputs of Algorithm .

A witness  that generate 
 satisfying


A lower bound  on the number of conjugate pairs between  and .
A matrix  derived from the adjacency subgraph .
The number  of de Bruijn sequences. 
 


[h!]
Certifying the Existence of a Star Spanning Tree
[1]
A primitive polynomial  of degree .
Witness , , Matrix  and .


 the extension field of  defined by 

 from  to   will be a  matrix	
	 Berlekamp-Massey Algorithm
	
	Go to next 
		Initiate sets , , and 	 zero matrix
	 	

	 coset leader of 
	
	
	
	
	
	
		 from  to 
	
	
	line25
	Output  and 
	break 
				
	No star spanning tree centered at  found
		

The integer  in Line  of Algorithm  upper bounds the choice of . Running the algorithm with a random choice of  for all , we set   for  and  for . Limiting  in Line  to  was enough for all but very few parameter sets. The algorithm is practical. Averaging over  randomly selected primitive polynomials of degree , it took about  hour  minutes to compute the certificates for all valid  given a .


[p]
Examples of Star and Almost-Star Spanning Tree Certificates


ccccllccl
No. &  &  &  &  & Star Witness  &  &  & Time 

 &  &  &  &  &  &  &  & s 


 &  &  &  &  &  &  &  & ms
 
 & &  & &  &  & &  & 

 & &  & &  &  & &  & 

 & & & &  &   & & & 

 & & & &  &   & & & 


 &   &   &  &  &  &  &  & s 

&&&&&  && 


 &  &  &  &  &  &  &  & s 

 & & & &  & & & & 


No. &  &  &  &  & Almost-Star Witness  and  &  &  & Time 

 &  &  &  &  &  &  &  & s 

 & & & & & ,   & & & 


 &  &  &  &  & ,  &  &  & s 

 & & & &  & & & & 


 &  &  &  & See Entry  above &  &  &  & ms
 
 & &  & &  &  & &  & 

 & &  & &  &  & &  & 

 & & & &  &   & & & 

 & & & &  & ,  & & & 

    
 &   &  &  &  & ,  &  &  & s 


If no star spanning tree can be certified, one sets aside the unique edge  between  and  and modifies Algorithm  to find a certificate for star trees centered at  for a chosen  with vertices  for all  as the leaves. Adding  back yields almost-star spanning trees centered at  in . 
To be more precise, we replace  by  in Line  and replace  in Line  by . The entries of  defined in Lines  to  are now given as follow.

[1]
, 
 from  to 
, 


We do not obtain any star spanning tree centered at  for  and . There are  almost-star spanning trees centered at  with witness  and  as an associated irreducible polynomial. Similarly, there is no star spanning tree certificate for  and . Going through  produces certificates for almost-star spanning trees, , with  for  and  for all other s.

There are parameter sets for which there is a unique star spanning tree, yielding only  de Bruijn sequence. Examples include  with 
,  with , 
and  with . There are certificates for almost-star 
spanning trees for all of them, ensuring the existence of a large number of de Bruijn 
sequences in each case. The search takes longer but remains practical. 
Counting the number of, respectively, star and almost-star spanning trees (with center ) 
for  and  gives us  and  sequences while  yields  sequences.
 
Table  lists more examples. For a compact presentation we use sparse primitive polynomials. They are either trinomials, ,  with , or  with . 
MAGMA  easily generates such polynomials for . 
Given  and , the  
polynomials  and  are presented as sets whose elements are 
the powers of  between  and  whose coefficients are . Hence, for  and ,  
 and . 
Its witness  builds , 
implying . The corresponding sets  are
*
&20,9,18,5,10, 16,1,2,4,8, 14,28,25,19,7,

&13,26,21,11,22,23,15,30,29,27,12,24,17,3,6.
Their union is . Note that  and  share 
 conjugate pairs for . Computing for  is then straightforward. The other entries can be similarly interpreted. 
The recorded running time is for the specified  with  added for cases where the center of the almost-star trees is 
. Computations for the certificates are done on a laptop with Ubuntu 16.04 OS powered by an Intel Hasswell i5-4300U CPU 1.90GHz running MAGMA V2.20-10. The current limit for an efficient computation is  without a companion file of size  GB. With the file,  goes up to . 

A Basic Software Implementation for Cycle Joining
We make a basic implementation of the cycle joining method via Zech's logarithms  available online in . It requires python 2.7 equipped with sympy and some access to MAGMA, either locally or through internet connection. Many users care more about the speed of generation and need only a relatively small numbers of de Bruijn sequences. Others may prefer completeness and would like to produce all de Bruijn sequences that can be generated from the given input polynomial and a stipulated number  of cycles. We cater to both types of users. 

The software can take as inputs , a valid , and a desired number of de Bruijn sequences. First it produces the associated irreducible polynomial  before generating the (possibly partial) Zech's logarithm table. It ensures that  is the initial state of  and attempts to build an adjacency subgraph from the table. If not all vertices are connected, it identifies pairs of vertices that still need to be connected and uses the information to get the required Zech's logarithms through calls to MAGMA online calculator http://magma.maths.usyd.edu.au/calc/. It stops when a connected adjacency subgraph containing all vertices is obtained. Finally, it chooses the required number of spanning trees and produces de Bruijn sequences using the procedure explained in . Various modifications can be done on the routine to make it run faster, , if generating only a few de Bruijn sequences is all a user wants. 



There are  de Bruijn sequences from  and . It takes  seconds and a negligible amount of memory to output one of them. The simplified subadjacency graph, where multiple edges between two vertices is presented as one, is in Figure  with vertex  representing  and  representing . Using  and , it takes  minutes and  MB of memory to write one of  resulting sequences. [!t]
			A simplified subadjacency graph  for  with .
	

Harvesting the cyclotomic numbers 

So far there is no closed formula for cyclotomic numbers defined in (), except in several limited classes. Storer's textbook  and a more recent one by Ding  have more details. Determining the values computationally is a by-product of our implementation in which we obtain the respective cyclotomic numbers on the input parameters specified in Table . They are available for download in our  online repository .

The Input Parameters of the Computed  for 

 

Product of Irreducibles
The approach via Zech's logarithms can be used in tandem with the one in  to generate de Bruijn sequences of even larger orders. To keep the exposition brief, we retain the notations from the said reference.

Let  be a set of  pairwise distinct irreducible polynomials
over . Each  has degree , order  with , 
and a root . Let the respective associated primitive polynomials be  with 
degree  and root . Hence,
. Let the initial state of  be . The initial states 
of  for  follows by decimating the appropriate -sequence 
 generated by . For the rest of this section, let


We use the expression for the cycle structure of  given in . 
For any cycle  containing 
a state  the goal is to identify a cycle  that contains . Letting  be the matrix defined in , 
 with  for 
. One then gets a state  of some nonzero sequence in  satisfying . The exact position of each  
in the corresponding cycle in , , the exact value of 
satisfying  is computed using the method from Section  or by an exhaustive search when  is small. The conjugate state  of  must then be 

with  based on . 
If  is the -th state of  for all , then  must be in cycle
. 

Thus, given any nonzero cycle  in  we can determine any of its state , 
find the conjugate state , and the cycle  that  is a state of. If so desired, all conjugate pairs shared by any adjacent cycles can be determined explicitly. 
Finally, the steps detailed in  yield actual de Bruijn sequences.

Using  in () may become crucial when substantially more than  de Bruijn sequences of order a Mersenne exponent  need to be produced. The simplest choice is to use  with  an irreducible polynomial of a small degree, ,  or , and  any irreducible non-primitive polynomial of degree  or , respectively. If even more de Bruijn sequences are required, one should use  and choose a small  for  since computing the Zech logarithm table relative to a small  is easy.

Zech's Logarithms and Cross-Join Pairs
Mykkeltveit and Szmidt showed in  that, starting from any de Bruijn sequence of a given order , one can construct all de Bruijn sequences of that order by repeated applications of the cross-join pairing method. We now use Zech's logarithms to find the cross-join pairs of states. This enables us to construct the feedback functions of NLFSRs of maximum period. The Fryers Formula for an -sequence is a new analytic tool in the theory. We use the coefficients in the formula as an algorithmic tool here.

Basic Notions and Results

There is some Boolean function  on  variables such that any non-singular feedback function  satisfies 
 . A modified de Bruijn sequence  of order  is a sequence of length  obtained from a de Bruijn sequence  of order  by removing one zero from 's tuple of  consecutive zeros. 


() 
Let  be a de Bruijn sequence of order . Then there exists a Boolean function  such that 




Let  and  be two conjugate pairs from a feedback function , given . 
Then  is the corresponding cross-join pair generated by the FSR if the states  occur in exactly that order. Let  be a de Bruijn sequence of order  generated by the feedback function . Let  be the cross-join pair. Then the feedback function

generates a new de Bruijn sequence . The modified sequences  and  are similarly connected.

()
Let  and  be distinct de Bruijn sequences of order . Then   can be obtained from   by repeatedly applying the cross-join method.


Consider the de Bruijn sequences of order : 
*	
&=(0000 0110 1100 0100 1011 1110 0111 0101)  and 

&=(0000 0110 1110 1010 0101 1001 1111 0001).
	
Applying the method on  using the pair  results in an intermediate de Bruijn sequence  where a right arrow indicates a crossover jump.We obtain  by using the pair  on . The respective feedback functions
*
h_ & = x_0 + x_1  ( x_2 x_3 x_4 + x_2 x_4 + x_3 x_4 + x_3 + 1) 
+ x_2  (x_3 x_4 + x_3) + x_3 + 1, 

h_T & = x_0 + x_1  ( x_2 x_3 x_4 + x_2 x_3 + x_2 + x_3 x_4 + x_3 + 1) + x_2 x_3 + x_3 + 1, 

h_ & = x_0 + x_1  ( x_2 x_3 x_4 + x_2 x_4 + x_3 + 1) +  
x_2  (x_3 x_4 + x_4+1) + x_3 + 1,
satisfy Equation (). 
Zech's Logarithms as Positional Markings

The keen reader must have recognized by now that only a simple adaptation is required to determine cross-join pairs by using Zech's logarithms. Instead of identifying conjugate pairs whose respective components belong to distinct cycles, we use Zech's logarithms to identify states  that occur in that exact order in a given (modified) de Bruijn sequence . We retain the standard representation of states based on the  map with  as the initial state of any -sequence of order .

We demonstrate how to use Zech logarithms to recursively identify cross-join pairs in an -sequence to generate numerous feedback functions of the NLFSRs that produce modified de Bruijn sequences. Remark  comes in handy here. 

Let  be a root of the primitive trinomial . Using the  map, one gets  and . We use the notation  to refer to two pairs of states 
 and . 
Hence, the states of the LFSR, with  as the characteristic polynomial, at the crossover jumps are governed by  and . Thus,  and  while  for  and .  

The feedback function of the constructed NLFSR of period  is, therefore, 



with algebraic degree .

Now, consider the primitive trinomial . 
From  and  one obtains the following set of mutually disjoint cross-join pairs  




From this family we construct  NLFSRs. Each of them generates a modified de Bruijn sequence of period  whose feedback function has algebraic degree .

As in the cycle joining method, we give a basic software implementation in  with some randomness added in the procedure. The routine executes the following steps for any order .

	Choose a primitive polynomial  of degree  and generate the -sequence  from the initial state .
	Build the Zech's logarithm table based on . Note that in this simple implementation we use the approach suggested in Remark . For larger values of  it is more efficient to obtain the logarithms from MAGMA or its alternatives.
	Pick random distinct integers  and  satisfying .
	Construct the matrix  from Equation () and use the square-and-multiply technique based on the binary representations of  and  to quickly find
	



	The resulting feedback function of the modified de Bruijn sequence follows from applying Equation (), using  and , with  derived from .

Here is a small instance to illustrate the process.

On input , the routine selected . The chosen pair was  with 
. Hence,  and . The feedback function of the resulting modified de Bruijn sequence 
 is . 

Fryers' Formula for -Sequences

Let  be the set of functions  such that  generate de Bruijn sequences of order . 
For a function , we define the set 



The number of inputs for which the functions 
 and   are different equals . Let  denote the cardinality of  and . 
Let a linear function  be such that  generates an 
-sequence . In , Coppersmith, Rhoades, and Vanderkam proved the formula 

which they attribute to M. J. Fryers. The coefficients   can be calculated from the MacLaurin expansion for :
*
or simply by expanding the powers in Equation (). 

The value  implies that from  we obtain a unique de Bruijn sequence and joining the cycle of the zero state corresponds to one change in the truth table of the function . In general,  for all even  since an even number of changes in the truth table of  always lead to disjoint cycles. 

We discover an interesting combinatorial view on the non-vanishing () coefficients of the polynomial . Recall that  generates an -sequence of period . Sequence A281123 in OEIS  gives the formula for the positive coefficients of the polynomial



Hence, for odd , the formula for  is  

The number of cross-join pairs for an -sequence, given by the Helleseth and Klove formula


 
follows from (). The analogous formula for higher   

gives the number of de Bruijn sequences obtained after the -th application of cross-join method. One starts from  and append  to the longest string of zeroes to obtain a de Bruijn sequence . One then finds all of its cross-join pairs and use them to construct new de Bruijn sequences. For each of the sequences repeat the cross-join method  times.

Using () we easily obtain the number of de Bruijn sequences of order :

since  is the sum of the odd entries in row  of the Pascal Triangle. Note that the positive coefficients of  are symmetric. Let us examine some small orders. 

For , one gets . Hence, from a de Bruijn sequence , modified from , there are  de Bruijn sequences each that can be constructed by using , respectively , application(s) of the cross-join method. There is a unique de Bruijn sequence that requires  applications. For , we know the number of de Bruijn sequences of distance  cross-join pairs from a fixed -sequence of order  from the formula 




The Fryers formula for  can be easily generated by using Equation (). It tells us when to stop searching for more  cross-join pairs and suggests the following naive approach to generating all de Bruijn sequences of order . 

	Choose an -sequence  of period  and the corresponding linear recursion . Find all cross-join pairs in  and use Equation () to construct the corresponding feedback fuctions for the resulting  modified de Bruijn sequences.
	Find all cross-join pairs for each of the just constructed modified de Bruijn sequences and obtain feedback functions from those cross-join pairs. It may happen that some of the NLFSRs produced by different cross-join pairs are identical. A sieving mechanism is put in place in the second application to retain only distinct feedback functions. There are  of them.
	Repeat the application of the method to the end where only one new NLFSR appears. This ensures that the feedback functions of all modified de Bruijn sequences of order  have been explicitly determined.

This naive approach soon becomes impractical. Depending on the specific deployment needs, one can certainly throw in some random choices and various measures of stoppage to efficiently produce the feedback functions of only some de Bruijn sequences. The route via Zech's logarithms allows us to determine the algebraic degree of the resulting feedback function.

Conclusions
This work approaches the constructions of binary de Bruijn sequences for all orders  via Zech's logarithms and demonstrates their practical feasibility. Many such sequences of large orders are produced by both the cycle joining method and the cross-join pairing within reasonable time and memory expenditures. As computational tools we establish further properties of Zech's logarithms as well as a rapid method to generate irreducible polynomials of degree  from a primitive polynomial of degree . We show how to generate de Bruijn sequences of orders even larger than the current limit of MAGMA's efficient computation of Zech's logarithms by using LFSRs whose characteristic polynomial are products of distinct irreducible polynomials.

For a large , storing a de Bruijn sequence of order  is not feasible. Our proof-of-concept implementation determines the feedback functions of the resulting NLFSRs explicitly. This makes the approach highly suitable for both software and hardware designs to cater to application-specific requirements. In the cycle joining framework one may opt to output subsequent states up to some length, , measured in file size. The initial state and the spanning tree(s) can be randomly chosen. We also demonstrate how to use the Zech logarithms to quickly identify the cross-join pairs in any -sequence, especially the one whose characteristic polynomial is a trinomial or a pentanomial. This enables us to determine the feedback functions of the NLFSRs that generate the resulting modified de Bruijn sequences. We present some consequences of the Fryers formula and use them as computational tools.

Our constructions bypass the need for "scaling," which has been a common theme in the studies of NLFSRs since its introduction by Lempel in . Some notable recent investigations include the work of Dubrova in  and that of Mandal and Gong in . Our work also points to many open directions in the studies of NLFSRs that generate de Bruijn sequences or their modified sequences. A comprehensive analysis on their algebraic structure and complexity remains a worthy challenge to undertake.


M. F. Ezerman gratefully acknowledges the hospitality of the 
School of Mathematics and Statistics of Zhengzhou University, 
in particular Prof. Yongcheng Zhao, during several visits. 
The work of Z. Chang is supported by the National Natural Science 
Foundation of China Grant 61772476 and the Key Scientific Research 
Projects of Colleges and Universities in Henan Province Grant 18A110029. 
Research Grants TL-9014101684-01 and MOE2013-T2-1-041 support the research carried out by M. F. Ezerman, S. Ling, and H. Wang. Singapore Ministry of Education Grant M4011381 provides a partial support for A. A. Fahreza. J. Szmidt's work is supported by the Polish Ministery of Science and Higher Education Decision No. 6663/E-294/S/2018.




10
	[1]#1
	URL 
	urlstyle	[1]DOI #1	DOI 	rm	
		van Aardenne-Ehrenfest, T., de Bruijn, N.G.: Circuits and trees in oriented
	linear graphs.
	Simon Stevin 28, 203-217 (1951)
	
		Arndt, J.: Matters Computational: Ideas, Algorithms, Source Code, 1st edn.
	Springer-Verlag New York, Inc., New York, NY, USA (2010)
	
		Bosma, W., Cannon, J., Playoust, C.: The Magma algebra system. I. The
	user language.
	J. Symbolic Comput. 24(3-4), 235-265 (1997).
	Computational algebra and number theory (London, 1993)
	
		de Bruijn, N.G.: A combinatorial problem.
	Koninklijke Nederlandse Akademie v. Wetenschappen 49,
	758-764 (1946)
	
		Chang, Z., Ezerman, M.F., Ling, S., Wang, H.: On binary de Bruijn sequences
	from LFSRs with arbitrary characteristic polynomials.
	Des. Codes Cryptogr.  (2018).
	10.1007/s10623-018-0509-y
	
		Coppersmith, D., Rhoades, R.C., VanderKam, J.M.: Counting de Bruijn
	sequences as perturbations of linear recursions.
	ArXiv e-prints (1705.07835) (2017)
	
		Ding, C.: Codes from Difference Sets.
	World Scientific, Singapore (2014)
	
		Dong, J., Pei, D.: Construction for de Bruijn sequences with large stage.
	Des. Codes Cryptogr. 85(2), 343-358 (2017)
	
		Dubrova, E.: A scalable method for constructing Galois NLFSRs with period
	 using cross-join pairs.
	IEEE Trans. on Inform. Theory 59(1), 703-709 (2013)
	
		Ezerman, M.F., Fahreza, A.A.: A binary de Bruijn sequence generator from
	Zech's logarithms.
	https://github.com/adamasstokhorst/ZechdB (2017)
	
		Ezerman, M.F., Fahreza, A.A.: A binary de Bruijn sequence generator from
	product of irreducible polynomials.
	https://github.com/adamasstokhorst/debruijn (2018)
	
		Fredricksen, H.: A survey of full length nonlinear shift register cycle
	algorithms.
	SIAM Rev. 24(2), 195-221 (1982)
	
		Golomb, S.W.: Shift Register Sequences.
	Aegean Park Press, Laguna Hills (1981)
	
		Golomb, S.W., Gong, G.: Signal Design for Good Correlation: for Wireless
	Communication, Cryptography, and Radar.
	Cambridge Univ. Press, New York (2004)
	
		Hauge, E.R., Helleseth, T.: De Bruijn sequences, irreducible codes and
	cyclotomy.
	Discrete Math. 159(1-3), 143-154 (1996)
	
		Hauge, E.R., Mykkeltveit, J.: On the classification of de Bruijn sequences.
	Discrete Math. 148(1â€“3), 65 - 83 (1996)
	
		Helleseth, T., Klove, T.: The number of cross-join pairs in maximum length
	linear sequences.
	IEEE Trans. on Inform. Theory 37(6), 1731-1733 (1991)
	
		Huber, K.: Some comments on Zech's logarithms.
	IEEE Trans. on Inform. Theory 36(4), 946-950 (1990)
	
		Jacobi, C.: Uber die kreistheilung und ihre anwendung auf die
	zahlentheorie.
	Journal fur die reine und angewandte Mathematik 30,
	166-182 (1846)
	
		Lempel, A.: On a homomorphism of the de Bruijn graph and its applications to
	the design of feedback shift registers.
	IEEE Trans. on Computers C-19(12), 1204-1209 (1970)
	
		Lidl, R., Niederreiter, H.: Finite Fields.
	Encyclopaedia of Mathematics and Its Applications. Cambridge Univ.
	Press, New York (1997)
	
		Mandal, K., Gong, G.: Cryptographically strong de Bruijn sequences with large
	periods.
	In: L.R. Knudsen, H. Wu (eds.) Selected Areas in Cryptography, pp.
	104-118. Springer Berlin Heidelberg, Berlin, Heidelberg (2013)
	
		Menezes, A.J., Vanstone, S.A., Oorschot, P.C.V.: Handbook of Applied
	Cryptography, 1st edn.
	CRC Press, Inc., Boca Raton, FL, USA (1996)
	
		Mykkeltveit, J., Szmidt, J.: On cross joining de Bruijn sequences.
	Contemporary Mathematics 632, 333-344 (2015)
	
		Sloane, N.J.A.: The Online Encyclopedia of Integer Sequences: Mersenne
	exponents, primes  such that  is (Mersenne) prime.
	https://oeis.org/A000043
	
		Sloane, N.J.A.: The Online Encyclopedia of Integer Sequences:
	Triangle T read by rows.
	https://oeis.org/A281123
	
		Storer, T.: Cyclotomy and Difference Sets.
	Lectures in Advanced Mathematics. Markham Pub. Co., Chicago, USA
	(1967)
	



Tasks:

1. Put the cyclotomic numbers data online in zip file
2. For example 5, consider including the transition on the feedback function based on Eq. (19).